package sd

import (
	"encoding/hex"
	"testing"
)

func TestCRC(t *testing.T) {
	tests := []struct {
		block   string
		wantcrc uint16
	}{
		{
			block:   "fa33c08ed0bc007c8bf45007501ffbfcbf0006b90001f2a5ea1d060000bebe07b304803c80740e803c00751c83c610fecb75efcd188b148b4c028bee83c610fecb741a803c0074f4be8b06ac3c00740b56bb0700b40ecd105eebf0ebfebf0500bb007cb8010257cd135f730c33c0cd134f75edbea306ebd3bec206bffe7d813d55aa75c78bf5ea007c0000496e76616c696420706172746974696f6e207461626c65004572726f72206c6f6164696e67206f7065726174696e672073797374656d004d697373696e67206f7065726174696e672073797374656d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000094c6dffd0000000401040cfec2ff000800000000f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000055aa",
			wantcrc: 0x52ce,
		},
	}

	for _, tt := range tests {
		b, err := hex.DecodeString(tt.block)
		if err != nil {
			t.Fatal(err)
		}
		gotcrc := CRC16(b)
		if gotcrc != tt.wantcrc {
			t.Errorf("calculateCRC(%s) = %#x, want %#x", tt.block, gotcrc, tt.wantcrc)
		}
	}
}

func CRC16(buf []byte) (sum uint16) {
	const poly uint16 = 0x1021 // Generator polynomial G(x) = x^16 + x^12 + x^5 + 1
	var crc uint16 = 0x0000    // Initial value
	for _, b := range buf {
		crc ^= (uint16(b) << 8)  // Shift byte into MSB of crc
		for i := 0; i < 8; i++ { // Process each bit
			if crc&0x8000 != 0 {
				crc = (crc << 1) ^ poly
			} else {
				crc <<= 1
			}
		}
	}
	return crc
}
